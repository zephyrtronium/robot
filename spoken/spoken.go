package spoken

import (
	"context"
	_ "embed"
	"fmt"
	"iter"
	"time"

	"github.com/go-json-experiment/json"
	"zombiezen.com/go/sqlite/sqlitex"
)

// History records messages generated by robot.
type History struct {
	db *sqlitex.Pool
}

// meta is metadata that may be associated with a generated message.
type meta struct {
	// Orig is the original generated message, prior to applying any emote
	// or effect.
	Orig string `json:"orig,omitempty"`
	// Emote is the emote appended to the message.
	Emote string `json:"emote,omitempty"`
	// Effect is the name of the effect applied to the message.
	Effect string `json:"effect,omitempty"`
	// Cost is the time in nanoseconds spent generating the message.
	Cost int64 `json:"cost,omitempty,omitzero"`
}

// Open opens an existing history in a DB.
func Open(ctx context.Context, db *sqlitex.Pool) (*History, error) {
	conn, err := db.Take(ctx)
	defer db.Put(conn)
	if err != nil {
		return nil, fmt.Errorf("couldn't get connection from pool: %w", err)
	}
	if err := sqlitex.ExecuteScript(conn, schemaSQL, nil); err != nil {
		return nil, fmt.Errorf("couldn't initialize spoken messages schema: %w", err)
	}
	return &History{db}, nil
}

//go:embed schema.sql
var schemaSQL string

// Record records a message with its trace and metadata.
func (h *History) Record(ctx context.Context, tag, msg string, trace []string, tm time.Time, cost time.Duration, orig, emote, effect string) error {
	conn, err := h.db.Take(ctx)
	defer h.db.Put(conn)
	if err != nil {
		return fmt.Errorf("couldn't get connection to record trace: %w", err)
	}
	const insert = `INSERT INTO spoken (tag, msg, trace, time, meta) VALUES (:tag, :msg, JSONB(CAST(:trace AS TEXT)), :time, JSONB(CAST(:meta AS TEXT)))`
	st, err := conn.Prepare(insert)
	if err != nil {
		return fmt.Errorf("couldn't prepare statement to record trace: %w", err)
	}
	tr, err := json.Marshal(trace)
	if err != nil {
		// Should be impossible. Explode loudly.
		go panic(fmt.Errorf("spoken: couldn't marshal trace %#v: %w", trace, err))
	}
	m := &meta{
		Orig:   orig,
		Emote:  emote,
		Effect: effect,
		Cost:   cost.Nanoseconds(),
	}
	md, err := json.Marshal(m)
	if err != nil {
		// Again, should be impossible.
		go panic(fmt.Errorf("spoken: couldn't marshal metadata %#v: %w", m, err))
	}
	st.SetText(":tag", tag)
	st.SetText(":msg", msg)
	st.SetBytes(":trace", tr)
	st.SetInt64(":time", tm.UnixNano())
	st.SetBytes(":meta", md)
	if _, err := st.Step(); err != nil {
		return fmt.Errorf("couldn't insert spoken message: ")
	}
	return nil
}

// Trace obtains the trace and time of the most recent instance of a message.
// If the message has not been recorded, the results are empty with a nil error.
func (h *History) Trace(ctx context.Context, tag, msg string) ([]string, time.Time, error) {
	conn, err := h.db.Take(ctx)
	defer h.db.Put(conn)
	if err != nil {
		return nil, time.Time{}, fmt.Errorf("couldn't get conn to find trace: %w", err)
	}
	const sel = `SELECT JSON(trace), time FROM spoken WHERE tag=:tag AND msg=:msg ORDER BY time DESC LIMIT 1`
	st, err := conn.Prepare(sel)
	if err != nil {
		return nil, time.Time{}, fmt.Errorf("couldn't prepare statement to find trace: %w", err)
	}
	st.SetText(":tag", tag)
	st.SetText(":msg", msg)
	ok, err := st.Step()
	if err != nil {
		return nil, time.Time{}, fmt.Errorf("couldn't find trace: %w", err)
	}
	if !ok {
		return nil, time.Time{}, nil
	}
	tr := st.ColumnText(0)
	tm := st.ColumnInt64(1)
	var trace []string
	if err := json.Unmarshal([]byte(tr), &trace); err != nil {
		return nil, time.Time{}, fmt.Errorf("couldn't decode trace: %w", err)
	}
	// Clean up the statement.
	st.Step()
	return trace, time.Unix(0, tm), nil
}

func once2[K, V any](k K, v V) iter.Seq2[K, V] {
	return func(yield func(K, V) bool) {
		yield(k, v)
	}
}

// Since provides an iterator over all trace IDs since the given time.
func (h *History) Since(ctx context.Context, tag string, tm time.Time) iter.Seq2[string, error] {
	conn, err := h.db.Take(ctx)
	// NOTE(zeph): we don't defer return the conn here because we need it alive
	// for the entire iterator
	if err != nil {
		h.db.Put(conn)
		return once2("", fmt.Errorf("couldn't get conn to find recent traces: %w", err))
	}
	const sel = `SELECT DISTINCT value FROM spoken, JSON_EACH(spoken.trace) WHERE tag = :tag AND time >= :time`
	st, err := conn.Prepare(sel)
	if err != nil {
		h.db.Put(conn)
		return once2("", fmt.Errorf("couldn't prepare statement to find recent traces: %w", err))
	}
	st.SetText(":tag", tag)
	st.SetInt64(":time", tm.UnixNano())
	return func(yield func(string, error) bool) {
		defer h.db.Put(conn)
		// Always reset the statement so that we can return the conn to the
		// pool no matter why we exit the iterator.
		defer st.Reset()
		for {
			ok, err := st.Step()
			if err != nil {
				yield("", fmt.Errorf("couldn't get recent traces: %w", err))
				return
			}
			if !ok {
				return
			}
			if !yield(st.ColumnText(0), nil) {
				return
			}
		}
	}
}

// Message is data about a message recorded in the spoken history.
type Message struct {
	Text     string    `json:"text"`
	Trace    []string  `json:"trace"`
	Time     time.Time `json:"time"`
	Original string    `json:"orig,omitzero"`
	Cost     string    `json:"cost"`
	Emote    string    `json:"emote,omitzero"`
	Effect   string    `json:"effect,omitzero"`
}

// Previous gets the most recent n messages and their traces.
// The returned closures are always non-nil.
func (h *History) Previous(ctx context.Context, tag string, n int) (iter.Seq[Message], func() error) {
	var err error
	errf := func() error { return err }
	conn, err := h.db.Take(ctx)
	if err != nil {
		err = fmt.Errorf("couldn't get connection to find previous messages: %w", err)
		return func(yield func(Message) bool) {}, errf
	}
	const sel = `SELECT msg, JSON(trace), time, JSON(meta) FROM spoken WHERE tag = :tag ORDER BY time DESC LIMIT :n`
	st, err := conn.Prepare(sel)
	if err != nil {
		h.db.Put(conn)
		err = fmt.Errorf("couldn't prepare statement to find previous messages: %w", err)
		return func(yield func(Message) bool) {}, errf
	}
	st.SetText(":tag", tag)
	st.SetInt64(":n", int64(n))
	it := func(yield func(Message) bool) {
		defer h.db.Put(conn)
		defer st.Reset()
		for {
			var (
				m    Message
				meta meta
				ok   bool
			)
			ok, err = st.Step()
			if err != nil {
				err = fmt.Errorf("couldn't get previous messages: %w", err)
				return
			}
			if !ok {
				return
			}
			m.Text = st.ColumnText(0)
			if err = json.Unmarshal([]byte(st.ColumnText(1)), &m.Trace); err != nil {
				err = fmt.Errorf("couldn't decode trace: %w", err)
				return
			}
			m.Time = time.Unix(0, st.ColumnInt64(2))
			if err = json.Unmarshal([]byte(st.ColumnText(3)), &meta); err != nil {
				err = fmt.Errorf("couldn't decode metadata: %w", err)
				return
			}
			m.Original = meta.Orig
			m.Cost = time.Duration(meta.Cost).String()
			m.Emote = meta.Emote
			m.Effect = meta.Effect
			if !yield(m) {
				return
			}
		}
	}
	return it, errf
}
